---
title: "Tools"
description: "Understanding tools in Agency Swarm."
icon: "wrench"
---

Tools are the building blocks that give agents their capabilities. They are specialized functions or actions that agents can perform to interact with the environment, process data, communicate, and much more. By defining custom tools, you can extend the functionality of your agents to suit specific tasks or integrate with external systems.

## Understanding Tools

In Agency Swarm, tools are Python classes that inherit from `BaseTool`. They are defined using [Pydantic](https://docs.pydantic.dev/latest/) for data validation and settings management. Each tool encapsulates a specific piece of functionality that an agent can invoke during its operation.

**Key characteristics of tools:**

- **Modular:** Each tool performs a single, well-defined task.
- **Reusable:** Tools can be shared among multiple agents.
- **Extensible:** You can create custom tools to interact with APIs, process data, and more.

## Basic Process Overview for Creating Tools

To create a new tool in Agency Swarm, follow these steps:

1. **Plan the Tool's Purpose and Functionality:**
   - Define what the tool will do and how it will be used by agents.
2. **Create a New Python Class Inheriting from `BaseTool`:**
   - Import `BaseTool` and create a new class that extends it.
3. **Write a Clear Docstring Describing the Tool's Purpose:**
   - This docstring is crucial as it helps agents understand how to use the tool.
4. **Define Input Fields with Proper Types and Descriptions:**
   - Use Pydantic's `Field` to define the tool's input parameters.
5. **Implement the `run` Method with the Tool's Logic:**
   - Write the code that executes the tool's functionality.
6. **Test the Tool Independently:**
   - Ensure the tool works as expected before integrating it.
7. **Add the Tool to an Agent's Toolset:**
   - Include the tool in the agent's list of available tools.

## Creating Basic Tools

Let's walk through creating a simple tool step by step.

### Step 1: Import Necessary Modules

You'll need to import `BaseTool` from `agency_swarm.tools` and `Field` from `pydantic`.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
```

### Step 2: Define Your Tool Class

Create a new class that inherits from `BaseTool`. Write a clear docstring describing the tool's purpose.

```python
class Calculator(BaseTool):
    """
    A simple calculator tool that evaluates mathematical expressions.
    """
    expression: str = Field(
        ...,
        description="The mathematical expression to evaluate."
    )

    def run(self):
        # Implement the tool's functionality
        try:
            result = eval(self.expression)
            return str(result)
        except Exception as e:
            return f"Error calculating expression: {e}"
```

#### How Docstrings Affect Agent Behavior

Docstrings are parsed and included in the OpenAI schema of the respective tools. This allows agents to understand the tools they have at their disposal and perform function calls properly with this awareness. Developers should write good tool docstrings, clearly describing the tool's purpose and usage to facilitate effective agent interactions.

### Step 3: Define Input Fields

Use Pydantic fields to define the inputs your tool will accept.

#### Basic Field Types

Common field types include:

- `str` for strings
- `int` for integers
- `float` for floating-point numbers
- `bool` for boolean values

Example:

```python
from pydantic import Field

class ExampleTool(BaseTool):
    age: int = Field(..., description="User's age.")
    name: str = Field(..., description="User's full name.")
```

#### Required vs Optional Fields

- **Required Fields:** Use `...` (Ellipsis) to indicate a required field.

  ```python
  location: str = Field(..., description="The location to search.")
  ```

- **Optional Fields:** Provide a default value to make a field optional.

  ```python
  comments: str = Field("", description="Additional comments.")
  ```

  For lists, use `default_factory`:

  ```python
  from typing import List

  tags: List[str] = Field(default_factory=list, description="List of tags.")
  ```

#### Special Pydantic Types

Leverage Pydantic's special types for enhanced validation:

- `EmailStr` for validating email addresses (requires `pip install email-validator`)

  ```python
  from pydantic import EmailStr

  email: EmailStr = Field(..., description="User's email address.")
  ```

- `HttpUrl` for validating URLs

  ```python
  from pydantic import HttpUrl

  website: HttpUrl = Field(..., description="User's website URL.")
  ```

See more special types in [Pydantic's documentation](https://docs.pydantic.dev/latest/api/types/).

#### Field Descriptions and Their Impact

Field descriptions are used in the OpenAI function schemas presented to agents. They guide the agent in generating the correct inputs when calling the tool. Clear and descriptive field descriptions improve the agent's ability to use the tool effectively.

#### Default Values and Their Impact

Providing default values for fields makes them optional. Agents may omit these fields when invoking the tool, and the default values will be used. This can simplify tool usage but be cautious with defaults that might lead to unintended behavior.

### Step 4: Implement the `run` Method

Write the logic that the tool will execute when called.

```python
def run(self):
    # Implement the tool's functionality
    pass
```

### Step 5: Test the Tool Independently

Before integrating the tool with an agent, test it to ensure it behaves as expected.

```python
if __name__ == "__main__":
    # Test the Calculator tool
    calc = Calculator(expression="2 + 2 * 3")
    print(calc.run())  # Output should be '8'
```

### Step 6: Add the Tool to an Agent

Include the tool in an agent's list of tools.

```python
from agency_swarm import Agent
from .tools.calculator import Calculator

class MathAgent(Agent):
    def __init__(self):
        super().__init__(
            name="MathAgent",
            description="An agent capable of performing mathematical calculations.",
            tools=[Calculator],
            instructions="./instructions.md",
            temperature=0.5,
            max_prompt_tokens=2500,
        )
```

## Validation and Error Handling

Ensuring the reliability of agent outputs is critical, especially in production environments. Agency Swarm includes mechanisms for:

- **Tool Input/Output Validation:** Tools validate data before and after execution to reduce runtime errors through Pydantic integration.
- **Custom Validators:** Implement custom validation logic within tools using field validators and model validators.

### Field-Level Validators vs. Model Validators

#### Field Validators

- **Purpose:** Validate individual fields.
- **Usage:** Decorate methods with `@field_validator`, specifying the target field(s).
- **Example:**

  ```python
  from pydantic import field_validator

  class User(BaseTool):
      username: str

      @field_validator('username')
      @classmethod
      def validate_username(cls, value):
          if ' ' in value:
              raise ValueError('Username must not contain spaces')
          return value
  ```

#### Model Validators

- **Purpose:** Validate the entire model, allowing checks involving multiple fields.
- **Usage:** Decorate methods with `@model_validator`.
- **Example:**

  ```python
  from pydantic import model_validator

  class User(BaseTool):
      password: str
      confirm_password: str

      @model_validator(mode='after')
      def check_passwords_match(self):
          if self.password != self.confirm_password:
              raise ValueError('Passwords do not match')
          return self
  ```

### Using `llm_validator`

`llm_validator` is a powerful validation decorator that uses Language Models to validate field values based on custom rules.

- **Key Features:**
  - Uses LLMs for validation against natural language rules.
  - Can auto-correct invalid values with `allow_override=True`.
  - Provides detailed reasoning for validation failures.

- **Example:**

  ```python
  from agency_swarm import llm_validator
  from pydantic import Field

  class User(BaseTool):
      name: str = llm_validator("The name must be a full name in all lowercase")
      age: int = Field(..., description="The user's age.")

  try:
      user = User(name="Jason Liu", age=20)
  except ValidationError as e:
      print(e)
  ```

### Tool Error Handling

Proper error handling is crucial.

- **How Errors Affect Agent Behavior:**
  - Agents receive the error message and can decide to retry, adjust inputs, or report back to the user based on their programming.
- **Best Practices:**
  - Use try-except blocks to catch and handle exceptions.
  - Return informative error messages to guide agent behavior.

Example:

```python
def run(self):
    try:
        # Tool logic here
        pass
    except Exception as e:
        return f"An error occurred: {e}"
```

## Advanced Tool Features

### Controlling Execution with `ToolConfig`

Customize tool behavior using the `ToolConfig` inner class.

- **Attributes:**
  - `strict`: Enforces strict adherence to the output schema.
  - `one_call_at_a_time`: Ensures the agent processes each tool call's result before making another call.

#### Using `strict` Mode

Enables precise output schema adherence, improving reliability.

```python
class GetWeatherTool(BaseTool):
    """
    Determine the weather in a specified location.
    """
    location: str = Field(..., description="The city and state, e.g., 'San Francisco, CA'")

    class ToolConfig:
        strict = True  # Enforce strict adherence to the output schema

    def run(self):
        # Weather retrieval logic
        return f"The weather in {self.location} is sunny with a temperature of 75Â°F."
```

#### Using `one_call_at_a_time`

Prevents multiple consecutive calls to the same tool without processing results.

```python
class DatabaseQueryTool(BaseTool):
    """
    Query the database for information.
    """
    query: str = Field(..., description="The SQL query to execute.")

    class ToolConfig:
        one_call_at_a_time = True  # Ensures sequential processing

    def run(self):
        # Database query logic
        return f"Results for query '{self.query}': [...]"
```

## Best Practices for Tools

### Use Clear Descriptions

Provide detailed descriptions for tools and fields.

- **Tool Docstrings:**
  - Clearly explain the tool's purpose and usage.
- **Field Descriptions:**
  - Guide the agent in providing correct inputs.

### Validate Inputs Thoroughly

- Use Pydantic's validation features.
- Implement custom validators when necessary.

### Handle Exceptions Gracefully

- Catch and handle exceptions within the `run` method.
- Provide informative error messages.

### Avoid Hardcoding Sensitive Data

- Use environment variables for API keys and secrets.

### Define Constants Globally

- For values that don't change, define them outside the class.

### Use Enumerations or Literal Types

Restrict agent inputs to specific allowed values.

```python
from typing import Literal

class RunCommand(BaseTool):
    """
    Execute predefined system commands.
    """
    command: Literal["start", "stop"] = Field(..., description="Command to execute: 'start' or 'stop'.")

    def run(self):
        if self.command == "start":
            # Start command logic
            pass
        elif self.command == "stop":
            # Stop command logic
            pass
```

## Shared State Management

### Utilizing `shared_state`

Use `self._shared_state` to share information between tools or control execution flow.

```python
class QueryDatabase(BaseTool):
    """
    Query the database and store the context.
    """
    question: str = Field(..., description="The question to query.")

    def run(self):
        # Retrieve context
        context = "This is the retrieved context."
        self._shared_state['context'] = context
        return "Context retrieved and stored."

class AnswerQuestion(BaseTool):
    """
    Answer a question using the stored context.
    """
    def run(self):
        context = self._shared_state.get('context')
        if not context:
            return "No context available. Please retrieve context first."
        # Use the context to generate an answer
        answer = f"Based on the context: {context}"
        return answer
```

## Complex Tool Examples

### Example: Email Sending Tool

```python
from agency_swarm.tools import BaseTool
from pydantic import Field, EmailStr

class EmailSender(BaseTool):
    """
    Sends emails after planning the content and recipients.
    """
    chain_of_thought: str = Field(
        ...,
        description="Plan how to construct the email. Consider the recipient, subject, and content."
    )
    recipient: EmailStr = Field(..., description="Email recipient's address.")
    subject: str = Field(..., description="Subject of the email.")
    body: str = Field(..., description="Content of the email.")

    def run(self):
        # Implement email sending logic, e.g., using smtplib
        return "Email sent successfully."
```

### Example: GitHub Repository Tool

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
import os
from github import Github

class GitHubTool(BaseTool):
    """
    Interact with GitHub repositories to list and create issues.
    """
    repo_name: str = Field(..., description="Repository name in 'owner/repo' format.")
    action: Literal["list_issues", "create_issue"] = Field(..., description="Action to perform.")
    issue_title: str = Field(None, description="Title of the issue to create.")
    issue_body: str = Field(None, description="Body content of the issue to create.")

    def run(self):
        github_token = os.getenv("GITHUB_TOKEN")
        if not github_token:
            return "GitHub token not found in environment variables."
        github = Github(github_token)
        try:
            repo = github.get_repo(self.repo_name)
            if self.action == "list_issues":
                issues = repo.get_issues(state='open')
                return [issue.title for issue in issues]
            elif self.action == "create_issue":
                if not self.issue_title:
                    return "Issue title is required to create an issue."
                issue = repo.create_issue(title=self.issue_title, body=self.issue_body)
                return f"Issue '{issue.title}' created successfully."
            else:
                return "Invalid action specified."
        except Exception as e:
            return f"Error interacting with GitHub: {e}"
```

## Common Patterns

### Method Composition

Combine multiple methods to handle complex operations.

```python
class CompositeTool(BaseTool):
    """
    A tool that combines several methods to perform a series of actions.
    """
    input_data: str = Field(..., description="Input data for the composite operation.")

    def run(self):
        # Step 1: Process data
        processed_data = self.process_data(self.input_data)
        # Step 2: Analyze results
        analysis = self.analyze_results(processed_data)
        # Step 3: Format output
        output = self.format_output(analysis)
        return output

    def process_data(self, data):
        # Implement data processing logic
        pass

    def analyze_results(self, data):
        # Implement analysis logic
        pass

    def format_output(self, data):
        # Implement output formatting
        pass
```

### Using Chain-of-Thought Parameters

Improve function call accuracy by adding a planning parameter.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field

class ComplexAnalysisTool(BaseTool):
    """
    Performs complex analysis after planning the approach.
    """
    chain_of_thought: str = Field(
        ...,
        description="Plan the analysis steps and considerations."
    )
    data: str = Field(..., description="Data to analyze.")

    def run(self):
        # Analysis logic
        return "Analysis complete."
```

## Testing Tools

Include test cases to ensure tools work as intended.

```python
if __name__ == "__main__":
    # Test the EmailSender tool
    email_sender = EmailSender(
        chain_of_thought="Plan to inform the team about the update.",
        recipient="user@example.com",
        subject="Project Update",
        body="The project is on track."
    )
    print(email_sender.run())  # Expected output: 'Email sent successfully.'
```

## ToolFactory Class

The `ToolFactory` class allows you to create tools from different sources, such as Langchain tools or OpenAPI schemas. However, implementing tools from scratch using `BaseTool` provides greater control and is generally recommended.

### Import from Langchain (Not Recommended)

```python
from langchain.tools import YouTubeSearchTool
from agency_swarm.tools import ToolFactory

LangchainTool = ToolFactory.from_langchain_tool(YouTubeSearchTool)
```

### Convert from OpenAPI Schemas

```python
import requests
from agency_swarm.tools import ToolFactory

# Using a local OpenAPI schema file
with open("schemas/your_schema.json") as f:
    tools = ToolFactory.from_openapi_schema(f.read())

# Using an OpenAPI schema from a URL
tools = ToolFactory.from_openapi_schema(
    requests.get("https://api.example.com/openapi.json").json(),
)
```

## Conclusion

By leveraging tools in Agency Swarm, you can significantly extend the capabilities of your agents. Whether interacting with external APIs, processing data, or executing code, tools enable agents to perform complex tasks efficiently.

Remember to:

- **Define Clear and Concise Tool Functionalities:**
  - Clearly state what the tool does.
- **Provide Detailed Descriptions for Tools and Fields:**
  - Help agents understand how to use the tool effectively.
- **Validate Inputs with Pydantic:**
  - Use `Field`, `field_validator`, and `model_validator`.
- **Handle Exceptions Gracefully:**
  - Prevent agent failures by managing unexpected issues.
- **Include Test Cases:**
  - Ensure your tools work as intended before deployment.

---
