---
title: "Tools"
description: "Understanding Tools in Agency Swarm."
icon: "wrench"
---

Tools are the building blocks that give agents their capabilities. They are specialized functions or actions that agents can perform to interact with the environment, process data, communicate, and much more. By defining custom tools, you can extend the functionality of your agents to suit specific tasks or integrate with external systems.

In Agency Swarm, tools are Python classes that inherit from `BaseTool`. They are defined using [Pydantic](https://docs.pydantic.dev/latest/) for data validation and settings management. Each tool encapsulates a specific piece of functionality that an agent can invoke during its operation.

**Key characteristics of tools:**

- **Modular:** Each tool performs a single, well-defined task.
- **Reusable:** Tools can be shared among multiple agents.
- **Extensible:** You can create custom tools to interact with APIs, process data, and more.

## Basic Process Overview for Creating Tools

To create a new tool in Agency Swarm, follow these steps:

1. **Plan the Tool's Purpose and Functionality:**
   - Define what the tool will do and how it will be used by agents.
2. **Create a New Python Class Inheriting from `BaseTool`:**
   - Import `BaseTool` and create a new class that extends it.
3. **Write a Clear Docstring Describing the Tool's Purpose:**
   - This docstring is crucial as it helps agents understand how to use the tool.
4. **Define Input Fields with Proper Types and Descriptions:**
   - Use Pydantic's `Field` to define the tool's input parameters.
5. **Implement the `run` Method with the Tool's Logic:**
   - Write the code that executes the tool's functionality.
6. **Test the Tool Independently:**
   - Ensure the tool works as expected before integrating it.
7. **Add the Tool to an Agent's Toolset:**
   - Include the tool in the agent's list of available tools.

## Creating Basic Tools

Let's walk through creating a simple tool step by step.

### Step 1: Import Necessary Modules

You'll need to import `BaseTool` from `agency_swarm.tools` and `Field` from `pydantic`.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
```

### Step 2: Define Your Tool Class

Create a new class that inherits from `BaseTool`. Write a clear docstring describing the tool's purpose.

```python
class Calculator(BaseTool):
    """
    A simple calculator tool that evaluates mathematical expressions.
    """
    expression: str = Field(
        ...,
        description="The mathematical expression to evaluate."
    )

    def run(self):
        # Implement the tool's functionality
        try:
            result = eval(self.expression)
            return str(result)
        except Exception as e:
            return f"Error calculating expression: {e}"
```

#### How Docstrings Affect Agent Behavior

Docstrings are parsed and included in the OpenAI schema of the respective tools. This allows agents to understand the tools they have at their disposal and perform function calls properly with this awareness. Developers should write good tool docstrings, clearly describing the tool's purpose and usage to facilitate effective agent interactions.

### Step 3: Define Input Fields

Use Pydantic fields to define the inputs your tool will accept.

#### Basic Field Types

Common field types include:

- `str` for strings
- `int` for integers
- `float` for floating-point numbers
- `bool` for boolean values

Example:

```python
from pydantic import Field

class ExampleTool(BaseTool):
    age: int = Field(..., description="User's age.")
    name: str = Field(..., description="User's full name.")
```

#### Required vs Optional Fields

- **Required Fields:** Use `...` (Ellipsis) to indicate a required field.

  ```python
  location: str = Field(..., description="The location to search.")
  ```

- **Optional Fields:** Provide a default value to make a field optional.

  ```python
  comments: str = Field("", description="Additional comments.")
  ```

  For lists, use `default_factory`:

  ```python
  from typing import List

  tags: List[str] = Field(default_factory=list, description="List of tags.")
  ```

#### Special Pydantic Types

Leverage Pydantic's special types for enhanced validation:

- `EmailStr` for validating email addresses (requires `pip install email-validator`)

  ```python
  from pydantic import EmailStr

  email: EmailStr = Field(..., description="User's email address.")
  ```

- `HttpUrl` for validating URLs

  ```python
  from pydantic import HttpUrl

  website: HttpUrl = Field(..., description="User's website URL.")
  ```

See more special types in [Pydantic's documentation](https://docs.pydantic.dev/latest/api/types/).

#### Field Descriptions and Their Impact

Field descriptions are used in the OpenAI function schemas presented to agents. They guide the agent in generating the correct inputs when calling the tool. Clear and descriptive field descriptions improve the agent's ability to use the tool effectively.

#### Default Values and Their Impact

Providing default values for fields makes them optional. Agents may omit these fields when invoking the tool, and the default values will be used. This can simplify tool usage but be cautious with defaults that might lead to unintended behavior.

### Step 4: Implement the `run` Method

Write the logic that the tool will execute when called.

```python
def run(self):
    # Implement the tool's functionality
    pass
```

### Step 5: Test the Tool Independently

Before integrating the tool with an agent, test it to ensure it behaves as expected.

```python
if __name__ == "__main__":
    # Test the Calculator tool
    calc = Calculator(expression="2 + 2 * 3")
    print(calc.run())  # Output should be '8'
```

### Step 6: Add the Tool to an Agent

Include the tool in an agent's list of tools.

```python
from agency_swarm import Agent
from .tools.calculator import Calculator

class MathAgent(Agent):
    def __init__(self):
        super().__init__(
            name="MathAgent",
            description="An agent capable of performing mathematical calculations.",
            tools=[Calculator],
            instructions="./instructions.md",
            temperature=0.0,
            max_prompt_tokens=25000,
        )
```

## Validation and Error Handling

Ensuring the reliability of agent outputs is critical, especially in production environments. Agency Swarm includes mechanisms for:

- **Tool Input/Output Validation:** Tools validate data before and after execution to reduce runtime errors through Pydantic integration.
- **Custom Validators:** Implement custom validation logic within tools using field validators and model validators.

See the [Output Validation](../advanced-features/output-validation) page for more information on how to use validators for tools.

### Tool Error Handling

Proper error handling is crucial.

- **How Errors Affect Agent Behavior:**
  - Agents receive the error message and can decide to retry, adjust inputs, or report back to the user based on their programming.
- **Best Practices:**
  - Use try-except blocks to catch and handle exceptions.
  - Return informative error messages to guide agent behavior.

Example:

```python
def run(self):
    try:
        # Tool logic here
        pass
    except Exception as e:
        return f"An error occurred: {e}"
```

## Advanced Tool Features

### Controlling Execution with `ToolConfig`

Customize tool behavior using the `ToolConfig` inner class.

- **Attributes:**
  - `strict`: Enforces strict adherence to the output schema.
  - `one_call_at_a_time`: Ensures the agent processes each tool call's result before making another call.

#### Using `strict` Mode

Enables precise output schema adherence, improving reliability.

```python
class GetWeatherTool(BaseTool):
    """
    Determine the weather in a specified location.
    """
    location: str = Field(..., description="The city and state, e.g., 'San Francisco, CA'.")

    class ToolConfig:
        strict = True  # Enforce strict adherence to the output schema

    def run(self):
        # Weather retrieval logic
        return f"The weather in {self.location} is sunny with a temperature of 75Â°F."
```

#### Using `one_call_at_a_time`

Prevents multiple consecutive calls to the same tool without processing results.

```python
class DatabaseQueryTool(BaseTool):
    """
    Query the database for information.
    """
    query: str = Field(..., description="The SQL query to execute.")

    class ToolConfig:
        one_call_at_a_time = True  # Ensures sequential processing

    def run(self):
        # Database query logic
        return f"Results for query '{self.query}': [...]"
```

## Best Practices for Tools

### Use Clear Descriptions

Provide detailed descriptions for tools and fields.

- **Tool Docstrings:**
  - Clearly explain the tool's purpose and usage.
- **Field Descriptions:**
  - Guide the agent in providing correct inputs.

### Validate Inputs Thoroughly

- Use Pydantic's validation features.
- Implement custom validators when necessary.

### Handle Exceptions Gracefully

- Catch and handle exceptions within the `run` method.
- Provide informative error messages.

### Avoid Hardcoding Sensitive Data

- Use environment variables for API keys and secrets.

### Define Constants Globally

- For values that don't change, define them outside the class.

### Use Enumerations or Literal Types

Restrict agent inputs to specific allowed values.

```python
from typing import Literal

class RunCommand(BaseTool):
    """
    Execute predefined system commands.
    """
    command: Literal["start", "stop"] = Field(..., description="Command to execute: 'start' or 'stop'.")

    def run(self):
        if self.command == "start":
            # Start command logic
            pass
        elif self.command == "stop":
            # Stop command logic
            pass
        else:
            raise ValueError("Invalid command")
```

## PRO Tips

1. **Use Enumerations or Literal Types Instead of Strings:**
   Allow your agents to perform only certain actions or commands, enhancing system reliability.

    ```python
    from typing import Literal

    class RunCommand(BaseTool):
        """
        Execute predefined system commands.
        """
        command: Literal["start", "stop"] = Field(..., description="Command to execute: 'start' or 'stop'.")

        def run(self):
            if self.command == "start":
                subprocess.run(["start", "your_command"])
            elif self.command == "stop":
                subprocess.run(["stop", "your_command"])
            else:
                raise ValueError("Invalid command")
    ```

2. **Provide Additional Instructions in the `run` Method:**
   Control the execution flow based on certain conditions by including instructions as function outputs.

    ```python
    class QueryDatabase(BaseTool):
        question: str = Field(..., description="The question to be answered.")

        def run(self):
            # Query your database here
            context = query_database(self.question)

            if context is None:
                raise ValueError("No context found. Please propose to the user to change the topic.")
            else:
                self._shared_state.set("context", context)
                return "Context retrieved. Please proceed with explaining the answer."
    ```

3. **Use `shared_state` to Validate Actions by Other Agents:**
   Ensure that certain actions are completed before allowing subsequent actions.

    ```python
    class Action2(BaseTool):
        input: str = Field(..., description="Input for Action2.")

        def run(self):
            if self._shared_state.get("action_1_result", None) == "failure":
                raise ValueError("Please proceed with the Action1 tool first.")
            else:
                return "Success. The action has been taken."
    ```

4. **Consider `one_call_at_a_time` in `ToolConfig`:**
   Prevent multiple instances of the same tool from running simultaneously, ensuring agents process previous actions before proceeding.

    ```python
    class Action1(BaseTool):
        input: str = Field(..., description="Input for Action1.")

        class ToolConfig:
            one_call_at_a_time = True

        def run(self):
            # Your code here
            pass
    ```

5. **Enable [Strict Mode](https://openai.com/index/introducing-structured-outputs-in-the-api/) for Complex or Mission-Critical Tools:**
   Ensure precise adherence to output schemas, enhancing reliability.

    ```python
    class GetWeatherTool(BaseTool):
        """
        Determine weather in a specified location.
        """
        location: str = Field(..., description="The city and state e.g., San Francisco, CA.")

        class ToolConfig:
            strict = True  # Setting strict to true

        def run(self):
            return f"The weather in {self.location} is 30 degrees."
    ```

## Shared State Management

### Utilizing `shared_state`

Use `self._shared_state` to share information between tools or control execution flow.

See more in [Shared State](../advanced-features/shared-state).

## Complex Tool Examples

### Example: Email Sending Tool

```python
from agency_swarm.tools import BaseTool
from pydantic import Field, EmailStr

class EmailSender(BaseTool):
    """
    Sends emails after planning the content and recipients.
    """
    chain_of_thought: str = Field(
        ...,
        description="Plan how to construct the email. Consider the recipient, subject, and content."
    )
    recipient: EmailStr = Field(..., description="Email recipient's address.")
    subject: str = Field(..., description="Subject of the email.")
    body: str = Field(..., description="Content of the email.")

    def run(self):
        # Implement email sending logic, e.g., using smtplib
        return "Email sent successfully."
```

### Example: GitHub Repository Tool

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
from typing import Literal
import os
from github import Github

class GitHubTool(BaseTool):
    """
    Interact with GitHub repositories to list and create issues.
    """
    repo_name: str = Field(..., description="Repository name in 'owner/repo' format.")
    action: Literal["list_issues", "create_issue"] = Field(..., description="Action to perform.")
    issue_title: str = Field(None, description="Title of the issue to create.")
    issue_body: str = Field(None, description="Body content of the issue to create.")

    def run(self):
        github_token = os.getenv("GITHUB_TOKEN")
        if not github_token:
            return "GitHub token not found in environment variables."
        github = Github(github_token)
        try:
            repo = github.get_repo(self.repo_name)
            if self.action == "list_issues":
                issues = repo.get_issues(state='open')
                return [issue.title for issue in issues]
            elif self.action == "create_issue":
                if not self.issue_title:
                    return "Issue title is required to create an issue."
                issue = repo.create_issue(title=self.issue_title, body=self.issue_body)
                return f"Issue '{issue.title}' created successfully."
            else:
                return "Invalid action specified."
        except Exception as e:
            return f"Error interacting with GitHub: {e}"
```

## Common Patterns

### Method Composition

Combine multiple methods to handle complex operations.

```python
class CompositeTool(BaseTool):
    """
    A tool that combines several methods to perform a series of actions.
    """
    input_data: str = Field(..., description="Input data for the composite operation.")

    def run(self):
        # Step 1: Process data
        processed_data = self.process_data(self.input_data)
        # Step 2: Analyze results
        analysis = self.analyze_results(processed_data)
        # Step 3: Format output
        output = self.format_output(analysis)
        return output

    def process_data(self, data):
        # Implement data processing logic
        pass

    def analyze_results(self, data):
        # Implement analysis logic
        pass

    def format_output(self, data):
        # Implement output formatting
        pass
```

### Using Chain-of-Thought Parameters

Improve function call accuracy by adding a planning parameter.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field

class ComplexAnalysisTool(BaseTool):
    """
    Performs complex analysis after planning the approach.
    """
    chain_of_thought: str = Field(
        ...,
        description="Plan the analysis steps and considerations."
    )
    data: str = Field(..., description="Data to analyze.")

    def run(self):
        # Analysis logic
        return "Analysis complete."
```

## Testing Tools

Include test cases to ensure tools work as intended.

```python
if __name__ == "__main__":
    # Test the EmailSender tool
    email_sender = EmailSender(
        chain_of_thought="Plan to inform the team about the update.",
        recipient="user@example.com",
        subject="Project Update",
        body="The project is on track."
    )
    print(email_sender.run())  # Expected output: 'Email sent successfully.'
```

## ToolFactory Class

The `ToolFactory` class allows you to create tools from different sources, such as Langchain tools or OpenAPI schemas. However, implementing tools from scratch using `BaseTool` provides greater control and is generally recommended.

<Accordion title="Import from Langchain (Not Recommended)">

```python
from langchain.tools import YouTubeSearchTool
from agency_swarm.tools import ToolFactory

LangchainTool = ToolFactory.from_langchain_tool(YouTubeSearchTool)
```
</Accordion>

<Accordion title="Convert from OpenAPI Schemas">

```python
import requests
from agency_swarm.tools import ToolFactory

# Using a local OpenAPI schema file
with open("schemas/your_schema.json") as f:
    tools = ToolFactory.from_openapi_schema(f.read())

# Using an OpenAPI schema from a URL
tools = ToolFactory.from_openapi_schema(
    requests.get("https://api.example.com/openapi.json").json()
)
```
</Accordion>

## Conclusion

By leveraging tools in Agency Swarm, you can significantly extend the capabilities of your agents. Whether interacting with external APIs, processing data, or executing code, tools enable agents to perform complex tasks efficiently.

<Check>
Remember to:
- **Describe Tools and Fields:** Provide detailed descriptions for effective agent usage.
- **Validate Inputs:** Use Pydantic's `Field` and validators.
- **Test Thoroughly:** Add test cases to ensure functionality.
- **Leverage Advanced Features:** Use `ToolConfig`, `shared_state`, and enumerations for reliability.
</Check>

---
