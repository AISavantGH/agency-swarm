---
title: "Tools"
description: "Learn how to create and use tools to enhance your agents' capabilities in Agency Swarm"
icon: "wrench"
---

# Tools in Agency Swarm

Tools are the building blocks that give agents their capabilities. They are specialized functions or actions that agents can perform to interact with the environment, process data, communicate, and much more. By defining custom tools, you can extend the functionality of your agents to suit specific tasks or integrate with external systems.

## Understanding Tools

In Agency Swarm, tools are Python classes that inherit from `BaseTool`. They are defined using [Pydantic](https://docs.pydantic.dev/latest/) for data validation and settings management. Each tool encapsulates a specific piece of functionality that an agent can invoke during its operation.

**Key characteristics of tools:**

- **Modular:** Each tool performs a single, well-defined task.
- **Reusable:** Tools can be shared among multiple agents.
- **Extensible:** You can create custom tools to interact with APIs, process data, and more.

## Creating Basic Tools

Let's walk through creating a simple tool step by step.

### Step 1: Import Necessary Modules

You'll need to import `BaseTool` from `agency_swarm.tools` and `Field` from `pydantic`. If your tool interacts with external systems or requires environment variables, import those as well.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
import os
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from a .env file
```

### Step 2: Define Your Tool Class

Create a new class that inherits from `BaseTool`. Use Pydantic fields to define the inputs your tool will accept.

```python
class Calculator(BaseTool):
    """
    A simple calculator tool that evaluates mathematical expressions.
    """
    expression: str = Field(
        ...,
        description="The mathematical expression to evaluate."
    )

    def run(self):
        # Implement the tool's functionality
        try:
            result = eval(self.expression)
            return str(result)
        except Exception as e:
            return f"Error calculating expression: {e}"
```

### Step 3: Add the Tool to an Agent

To use your new tool, add it to an agent's list of tools.

```python
from agency_swarm import Agent
from .tools.calculator import Calculator

class MathAgent(Agent):
    def __init__(self):
        super().__init__(
            name="MathAgent",
            description="An agent capable of performing mathematical calculations.",
            tools=[Calculator],
            instructions="./instructions.md",
            temperature=0.5,
            max_prompt_tokens=2500,
        )
```

## Advanced Tool Features

### Controlling Execution with `ToolConfig`

The `ToolConfig` allows you to customize tool behavior with additional settings. Currently, two key attributes are supported:

- `strict`: When set to `True`, enables strict mode for structured outputs. This means the agent must produce outputs that exactly match the expected schema, reducing errors in tool execution.
- `one_call_at_a_time`: When set to `True`, ensures that the agent processes each tool call's result before making another call to the same tool. This prevents multiple consecutive invocations of the same tool within a single response.

#### Using `strict` for Structured Outputs

By default, tools are responsible for parsing agent outputs and returning errors if the output doesn't match the expected schema. 
However, correcting errors can be difficult for the model, so you can set `strict = True` in `ToolConfig` to enforce precise adherence to the output schema.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field

class GetWeatherTool(BaseTool):
    """
    Determine weather in a specified location.
    """

    location: str = Field(..., description="The city and state, e.g., 'San Francisco, CA'")

    class ToolConfig:
        strict = True  # Enforce strict adherence to the output schema

    def run(self):
        # Implement weather retrieval logic
        return f"The weather in {self.location} is sunny with a temperature of 75Â°F."
```

With `strict` mode enabled, the agent is required to provide outputs that exactly match the expected format, which can improve reliability in mission-critical applications.

#### Using `one_call_at_a_time` to Control Tool Invocation

The `one_call_at_a_time` setting ensures that the agent processes the result of each tool invocation before making another call to the same tool. This is particularly useful for:

- **Preventing Infinite Loops or Repetitive Calls:** Ensures the agent doesn't get stuck making the same tool call repeatedly without processing results.
- **Ensuring Sequential Processing:** Guarantees that each tool call is handled individually, allowing for accurate reasoning and response generation.
- **Maintaining Structured Workflow:** Promotes a clear and organized sequence of actions within the agent's operations.
- **Reducing Resource Usage:** Minimizes unnecessary API calls or computational overhead by avoiding redundant tool invocations.

```python
class DatabaseQueryTool(BaseTool):
    """
    Query the database for information.
    """

    query: str = Field(..., description="The SQL query to execute.")

    class ToolConfig:
        one_call_at_a_time = True  # Ensures sequential processing of tool calls

    def run(self):
        # Implement database query logic
        return f"Results for query '{self.query}': [...]"
```

With this setting enabled, the agent must include additional reasoning or use different tools between consecutive calls to the database query tool, preventing rapid-fire queries without proper analysis of results.

### OpenAI Built-in Tools

Agency Swarm supports OpenAI's built-in tools, such as the Code Interpreter and File Search.

#### Using the Code Interpreter and File Search Tools

```python
from agency_swarm import Agent
from agency_swarm.tools import CodeInterpreter, FileSearch

class DataAgent(Agent):
    def __init__(self):
        super().__init__(
            name="DataAgent",
            description="An agent capable of executing code and searching files.",
            tools=[CodeInterpreter, FileSearch],
            instructions="./instructions.md",
        )
```

- **Code Interpreter:** Allows the agent to execute Python code in a sandboxed environment.
- **File Search:** Enables the agent to search and retrieve information from files.

### Best Practices for Tools

#### Using Chain-of-Thought (CoT) Parameters

To improve the accuracy of function calls, add a planning parameter (like `planning` or `chain_of_thought`) as a separate first parameter in your tool. This encourages the model to plan the parameter values before executing the function.

```python
from agency_swarm.tools import BaseTool
from pydantic import Field

class EmailSender(BaseTool):
    """
    Sends emails after planning the content and recipients.
    """
    chain_of_thought: str = Field(
        ...,
        description="Plan how to construct the email. Consider the recipient, subject, and content."
    )
    recipient: str = Field(..., description="Email recipient's address.")
    subject: str = Field(..., description="Subject of the email.")
    body: str = Field(..., description="Content of the email.")

    def run(self):
        # Implement email sending logic here
        # For example, using smtplib or a third-party email service
        return "Email sent successfully."
```

#### General Best Practices

- **Use Clear Descriptions:** Provide detailed descriptions for each field to guide the agent.
- **Validate Inputs:** Leverage Pydantic's validation to ensure inputs are correctly formatted.
- **Handle Exceptions:** Implement error handling within the `run` method to manage unexpected issues.
- **Avoid Hardcoding Sensitive Data:** Use environment variables for API keys and other sensitive information.
- **Define Constants Globally:** For values that don't change (e.g., API endpoints), define them outside the class.

## Complex Tool Examples

### Example: GitHub Repository Tool

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
import os
from github import Github

class GitHubTool(BaseTool):
    """
    Interact with GitHub repositories to list and create issues.
    """
    repo_name: str = Field(..., description="Repository name in 'owner/repo' format.")
    action: str = Field(..., description="Action to perform: 'list_issues' or 'create_issue'.")
    issue_title: str = Field(None, description="Title of the issue to create.")
    issue_body: str = Field(None, description="Body content of the issue to create.")

    def run(self):
        github_token = os.getenv("GITHUB_TOKEN")
        if not github_token:
            return "GitHub token not found in environment variables."
        github = Github(github_token)
        try:
            repo = github.get_repo(self.repo_name)
            if self.action == "list_issues":
                issues = repo.get_issues(state='open')
                return [issue.title for issue in issues]
            elif self.action == "create_issue":
                if not self.issue_title:
                    return "Issue title is required to create an issue."
                issue = repo.create_issue(title=self.issue_title, body=self.issue_body)
                return f"Issue '{issue.title}' created successfully."
            else:
                return "Invalid action specified."
        except Exception as e:
            return f"Error interacting with GitHub: {e}"
```

### Example: Data Processing Tool

```python
from agency_swarm.tools import BaseTool
from pydantic import Field
import pandas as pd

class DataProcessor(BaseTool):
    """
    Processes CSV data files and performs operations like summary and filtering.
    """
    file_path: str = Field(..., description="Path to the CSV data file.")
    operation: str = Field(..., description="Operation to perform: 'summary' or 'filter'.")
    filter_condition: str = Field(None, description="Condition for filtering data (e.g., 'age > 30').")

    def run(self):
        try:
            df = pd.read_csv(self.file_path)
            if self.operation == "summary":
                return df.describe().to_string()
            elif self.operation == "filter":
                if not self.filter_condition:
                    return "Filter condition is required for filtering operation."
                filtered_df = df.query(self.filter_condition)
                return filtered_df.to_csv(index=False)
            else:
                return "Invalid operation specified."
        except Exception as e:
            return f"Error processing data: {e}"
```

## Testing Tools

Include test cases at the bottom of your tool files to ensure they work as expected.

```python
if __name__ == "__main__":
    # Test the Calculator tool
    calc = Calculator(expression="2 + 2 * 3")
    print(calc.run())  # Output should be '8'
```

## Common Patterns

### Tool Composition

Combine multiple tools to handle complex operations.

```python
class CompositeTool(BaseTool):
    """
    A tool that combines other tools to perform a series of actions.
    """
    input_data: str = Field(..., description="Input data for the composite operation.")

    def run(self):
        # Step 1: Process data
        processed_data = self.process_data(self.input_data)
        # Step 2: Analyze results
        analysis = self.analyze_results(processed_data)
        # Step 3: Format output
        output = self.format_output(analysis)
        return output

    def process_data(self, data):
        # Implement data processing logic
        pass

    def analyze_results(self, data):
        # Implement analysis logic
        pass

    def format_output(self, data):
        # Implement output formatting
        pass
```

## PRO Tips

1. **Use Enums or Literal Types:** Use enumerated or literal types to restrict the agent's input to specific allowed values.

   ```python
   from typing import Literal

   class RunCommand(BaseTool):
       """
       Execute predefined system commands.
       """
       command: Literal["start", "stop"] = Field(..., description="Command to execute: 'start' or 'stop'.")

       def run(self):
           if self.command == "start":
               # Execute start command
               pass
           elif self.command == "stop":
               # Execute stop command
               pass
           else:
               raise ValueError("Invalid command.")
   ```

2. **Use Shared State:** Utilize `self._shared_state` to share information between tools or to control the execution flow based on previous actions.

   ```python
   class QueryDatabase(BaseTool):
       """
       Query the database and store the context.
       """
       question: str = Field(..., description="The question to query.")

       def run(self):
           # Assume we retrieve some context
           context = "This is the retrieved context."
           self._shared_state['context'] = context
           return "Context retrieved and stored."

   class AnswerQuestion(BaseTool):
       """
       Answer a question using the stored context.
       """
       def run(self):
           context = self._shared_state.get('context')
           if not context:
               return "No context available. Please retrieve context first."
           # Use the context to generate an answer
           answer = f"Based on the context: {context}"
           return answer
   ```

## Conclusion

By leveraging tools in Agency Swarm, you can extend the capabilities of your agents significantly. Whether it's interacting with external APIs, processing data, or executing code, tools make it possible for agents to perform complex tasks.

Remember to:

- **Define clear and concise tool functionalities.**
- **Provide detailed descriptions and validate inputs with Pydantic.**
- **Handle exceptions gracefully to prevent agent failures.**
- **Include test cases to ensure your tools work as intended.**

Feel free to explore and create custom tools that suit your specific needs. The modular nature of tools in Agency Swarm makes it easy to expand and adapt your agents' abilities over time.

---
